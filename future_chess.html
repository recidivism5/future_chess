<title>future chess</title>

<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Noto+Sans&family=Quicksand:wght@300;400&display=swap" rel="stylesheet">

<style>
	body {
		margin: 0;
		background-color: black;
	}
	canvas {
		display: block;  /* prevents scrollbar */
		width: 100vw;
		height: 100vh;
	}

	#overlay {
		user-select: none;
		color:white;
		position: absolute; 
		left: 50%;
		top: 15%;
	}

	.button {
		cursor:pointer;
		font-size:24px;
		display:inline-block;
		border: 1px solid white;
		padding:4px;
	}
	.button:hover {
		color: black;
		background-color: white;
		border: 1px solid black;
	}
</style>
<body>

<script src="board.js"></script>
<script src="linalg.js"></script>

<canvas id="canvas"></canvas>

<div id="overlay">
	<div style="font-size:120px;">future chess</div>
	<div class="button">copy room link</div><div style="padding-top:4px;">send to a friend</div>
</div>

<script>
	async function main(){
		var canvas = document.querySelector("#canvas");
		var gl = canvas.getContext("webgl2");
		if (!gl){
			console.error("WebGL 2 not available");
            document.body.innerHTML = "This example requires WebGL 2 which is unavailable on this system."
			return;
		}

		var boardShader = await load_shader("board");
		boardShader.uVP = gl.getUniformLocation(boardShader,"uVP");
		boardShader.uCamPos = gl.getUniformLocation(boardShader,"uCamPos");
		boardShader.uSkybox = gl.getUniformLocation(boardShader,"uSkybox");

		var pieceShader = await load_shader("piece");
		pieceShader.uTranslation = gl.getUniformLocation(pieceShader,"uTranslation");
		pieceShader.uMVP = gl.getUniformLocation(pieceShader,"uMVP");
		pieceShader.uCamPos = gl.getUniformLocation(pieceShader,"uCamPos");
		pieceShader.uSkybox = gl.getUniformLocation(pieceShader,"uSkybox");
		pieceShader.uColor = gl.getUniformLocation(pieceShader,"uColor");

		var skyboxShader = await load_shader("skybox");
		skyboxShader.uSkybox = gl.getUniformLocation(skyboxShader,"uSkybox");
		skyboxShader.uInvVP = gl.getUniformLocation(skyboxShader,"uInvVP");

		var board = await vao_from_obj("board");
		var bishop = await vao_from_obj("bishop");
		var king = await vao_from_obj("king");
		var knight = await vao_from_obj("knight");
		var pawn = await vao_from_obj("pawn");
		var queen = await vao_from_obj("queen");
		var rook = await vao_from_obj("rook");

		var skybox = load_cubemap("leafless_trees");

		var screenQuadVAO = gl.createVertexArray();
		gl.bindVertexArray(screenQuadVAO);
		var screenQuadBuf = gl.createBuffer();
		gl.bindBuffer(gl.ARRAY_BUFFER,screenQuadBuf);
		gl.bufferData(
			gl.ARRAY_BUFFER,
			new Float32Array([
				-1, -1, 
				1, -1, 
				-1,  1, 
				-1,  1,
				1, -1,
				1,  1,
			]),
			gl.STATIC_DRAW
		);
		gl.vertexAttribPointer(0,2,gl.FLOAT,false,0,0);
		gl.enableVertexAttribArray(0);

		gameBoard = new Board();
	
		requestAnimationFrame(drawScene);

		function drawScene(now){
			now *= 0.001; // convert to seconds

			resizeCanvasToDisplaySize(gl.canvas);
			gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);
			var aspect = gl.canvas.width/gl.canvas.height;

			gl.clearColor(1.0,0.0,0.0,1.0);
			gl.clear(gl.COLOR_BUFFER_BIT);

			gl.enable(gl.DEPTH_TEST);
			gl.enable(gl.CULL_FACE);

			var camPos = [7*Math.sin(now)+4,4,7*Math.cos(now)+4];
			var vp = mat4_mul(mat4_persp(0.5*Math.PI,aspect,0.01,2000.0),mat4_lookat(camPos,[4,0,4],[0,1,0]));
			
			gl.depthFunc(gl.LESS); // use the default depth test
			gl.useProgram(boardShader);
			gl.uniformMatrix4fv(boardShader.uVP,false,new Float32Array(vp.flat()));
			gl.uniform3fv(boardShader.uCamPos,new Float32Array(camPos));
			gl.uniform1i(boardShader.uSkybox,0);
			gl.bindTexture(gl.TEXTURE_CUBE_MAP,skybox);
			gl.bindVertexArray(board);
			gl.drawArrays(gl.TRIANGLES,0,board.vertexCount);

			gl.useProgram(pieceShader);
			gl.uniform3fv(pieceShader.uCamPos,new Float32Array(camPos));
			gl.uniform1i(pieceShader.uSkybox,0);
			gl.bindTexture(gl.TEXTURE_CUBE_MAP,skybox);
			for (var z = 0; z < 8; z++){
				for (var x = 0; x < 8; x++){
					var piecePos = [0.5+x,1,0.5+z];
					gl.uniform3fv(pieceShader.uTranslation,new Float32Array(piecePos));
					gl.uniformMatrix4fv(pieceShader.uMVP,false,new Float32Array(mat4_mul(vp,mat4_translate(piecePos)).flat()));
					var cell = gameBoard.cells[z][x];
					switch (cell.color){
						case "white":
							gl.uniform4fv(pieceShader.uColor,new Float32Array([1.0,1.0,1.0,1.0]));
							break;
						case "black":
							gl.uniform4fv(pieceShader.uColor,new Float32Array([0.0,0.0,0.0,1.0]));
							break;
					}
					switch (cell.type){
						case "bishop":
							gl.bindVertexArray(bishop);
							gl.drawArrays(gl.TRIANGLES,0,bishop.vertexCount);
							break;
						case "king":
							gl.bindVertexArray(king);
							gl.drawArrays(gl.TRIANGLES,0,king.vertexCount);
							break;
						case "knight":
							gl.bindVertexArray(knight);
							gl.drawArrays(gl.TRIANGLES,0,knight.vertexCount);
							break;
						case "pawn":
							gl.bindVertexArray(pawn);
							gl.drawArrays(gl.TRIANGLES,0,pawn.vertexCount);
							break;
						case "queen":
							gl.bindVertexArray(queen);
							gl.drawArrays(gl.TRIANGLES,0,queen.vertexCount);
							break;
						case "rook":
							gl.bindVertexArray(rook);
							gl.drawArrays(gl.TRIANGLES,0,rook.vertexCount);
							break;
					}
				}
			}

			gl.depthFunc(gl.LEQUAL); // let our quad pass the depth test at 1.0
			gl.useProgram(skyboxShader);
			gl.uniform1i(skyboxShader.uSkybox,0);
			gl.uniformMatrix4fv(skyboxShader.uInvVP,false,new Float32Array(mat4_invert(vp).flat()));
			gl.bindTexture(gl.TEXTURE_CUBE_MAP,skybox);
			gl.bindVertexArray(screenQuadVAO);
			gl.drawArrays(gl.TRIANGLES,0,6);

			requestAnimationFrame(drawScene);
		}
	
		function resizeCanvasToDisplaySize(canvas) {
			// Lookup the size the browser is displaying the canvas in CSS pixels.
			const displayWidth  = canvas.clientWidth;
			const displayHeight = canvas.clientHeight;

			// Check if the canvas is not the same size.
			const needResize = canvas.width  !== displayWidth ||
								canvas.height !== displayHeight;

			if (needResize) {
				// Make the canvas the same size
				canvas.width  = displayWidth;
				canvas.height = displayHeight;
			}
			return needResize;
		}

		async function load_shader(name){
			var vsRes = await fetch("shaders/"+name+"/vs.glsl");
			var vsSrc = await vsRes.text();

			var fsRes = await fetch("shaders/"+name+"/fs.glsl");
			var fsSrc = await fsRes.text();

			var vertexShader = gl.createShader(gl.VERTEX_SHADER);
			gl.shaderSource(vertexShader, vsSrc);
			gl.compileShader(vertexShader);

			if (!gl.getShaderParameter(vertexShader, gl.COMPILE_STATUS)) {
				console.error(gl.getShaderInfoLog(vertexShader));
			}

			var fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
			gl.shaderSource(fragmentShader, fsSrc);
			gl.compileShader(fragmentShader);

			if (!gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS)) {
				console.error(gl.getShaderInfoLog(fragmentShader));
			}

			var program = gl.createProgram();
			gl.attachShader(program, vertexShader);
			gl.attachShader(program, fragmentShader);
			gl.linkProgram(program);

			if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
				console.error(gl.getProgramInfoLog(program));
			}

			return program;
		}

		async function vao_from_obj(name){
			var response = await fetch("models/"+name+".obj");
			var text = await response.text();
			var lines = text.split('\n');

			var positions = [];
			var normals = [];
			var posIndices = [];
			var normIndices = [];
			for (var i = 0; i < lines.length; i++){
				if (lines[i].startsWith("v ")){
					var components = lines[i].split(' ');
					for (var j = 1; j < 4; j++){
						positions.push(parseFloat(components[j]));
					}
				} else if (lines[i].startsWith("vn ")){
					var components = lines[i].split(' ');
					for (var j = 1; j < 4; j++){
						normals.push(parseFloat(components[j]));
					}
				} else if (lines[i].startsWith("f ")){
					var components = lines[i].split(' ');
					for (var j = 1; j < 4; j++){
						var ind = components[j].split('/');
						posIndices.push(parseInt(ind[0])-1);
						normIndices.push(parseInt(ind[2])-1);
					}
				}
			}
			var verts = [];
			for (var i = 0; i < posIndices.length; i++){
				for (var j = 0; j < 3; j++){
					verts.push(positions[posIndices[i]*3+j]);
				}
				for (var j = 0; j < 3; j++){
					verts.push(normals[normIndices[i]*3+j]);
				}
			}

			var vao = gl.createVertexArray();
			gl.bindVertexArray(vao);
			vao.vbo = gl.createBuffer();
			gl.bindBuffer(gl.ARRAY_BUFFER,vao.vbo);
			gl.bufferData(gl.ARRAY_BUFFER,new Float32Array(verts),gl.STATIC_DRAW);
			gl.vertexAttribPointer(0,3,gl.FLOAT,false,6*4,0);
			gl.enableVertexAttribArray(0);
			gl.vertexAttribPointer(1,3,gl.FLOAT,false,6*4,3*4);
			gl.enableVertexAttribArray(1);

			vao.vertexCount = verts.length/6;
			return vao;
		}

		function load_cubemap(name){
			var texture = gl.createTexture();
			gl.bindTexture(gl.TEXTURE_CUBE_MAP, texture);
			
			const faceInfos = [
				{
					target: gl.TEXTURE_CUBE_MAP_NEGATIVE_X, 
					url: "cubemaps/"+name+"/nx.jpg"
				},
				{
					target: gl.TEXTURE_CUBE_MAP_POSITIVE_X, 
					url: "cubemaps/"+name+"/px.jpg"
				},
				{
					target: gl.TEXTURE_CUBE_MAP_NEGATIVE_Y, 
					url: "cubemaps/"+name+"/ny.jpg"
				},
				{
					target: gl.TEXTURE_CUBE_MAP_POSITIVE_Y, 
					url: "cubemaps/"+name+"/py.jpg"
				},{
					target: gl.TEXTURE_CUBE_MAP_NEGATIVE_Z, 
					url: "cubemaps/"+name+"/nz.jpg"
				},
				{
					target: gl.TEXTURE_CUBE_MAP_POSITIVE_Z, 
					url: "cubemaps/"+name+"/pz.jpg"
				},
			];
			faceInfos.forEach((faceInfo) => {
				const {target, url} = faceInfo;
				
				// Upload the canvas to the cubemap face.
				const level = 0;
				const internalFormat = gl.RGBA;
				const width = 2048;
				const height = 2048;
				const format = gl.RGBA;
				const type = gl.UNSIGNED_BYTE;
				
				// setup each face so it's immediately renderable
				gl.texImage2D(target, level, internalFormat, width, height, 0, format, type, null);
				
				// Asynchronously load an image
				const image = new Image();
				image.src = url;
				image.addEventListener('load', function() {
					// Now that the image has loaded upload it to the texture.
					gl.bindTexture(gl.TEXTURE_CUBE_MAP, texture);
					gl.texImage2D(target, level, internalFormat, format, type, image);
					gl.generateMipmap(gl.TEXTURE_CUBE_MAP);
				});
			});
			gl.generateMipmap(gl.TEXTURE_CUBE_MAP);
			gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_LINEAR);

			return texture;
		}
	}
	
	main();
</script>
</body>